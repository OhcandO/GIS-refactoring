<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: classes/MO.SourceFactory.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: classes/MO.SourceFactory.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as KEY from '../common/MO.keyMap.js';
import {MOFactory} from './abstract/MO.Factory.js';
import GeoJSON          from '../../lib/openlayers_v7.5.1/format/GeoJSON.js';
import WMTSCapabilities from '../../lib/openlayers_v7.5.1/format/WMTSCapabilities.js';
import WMTS, {optionsFromCapabilities} from '../../lib/openlayers_v7.5.1/source/WMTS.js';
import Source           from '../../lib/openlayers_v7.5.1/source/Source.js';
import XYZ              from '../../lib/openlayers_v7.5.1/source/XYZ.js';
import VectorSource     from '../../lib/openlayers_v7.5.1/source/Vector.js';
import { vworld_compatibilities } from '../vworld/vworldCompatibilities.js';

import { register } from '../../lib/openlayers_v7.5.1/proj/proj4.js';
import proj4 from '../../lib/proj4js-2.9.2/proj4j-2.9.2_esm.js';

/**
 * DB 에 있는 자료를 개별 레이어의 ol/source 로 구성하는 클래스.
 * (원래는 이 클래스가 Abstact Class 화 되어 WMTSSourceFactory 등으로 구현되었어야 함)
 * @export
 * @class MOSourceConfig
 * @author jhoh
 */
export class SourceFactory extends MOFactory{
    
    #default_sourceSpec = {
        // strategy : LoadingStrategy,//loading strategy. out of : all, bbox, tile
        crossOrigin : 'anonymous', //XYZ 
        minZoom : 19, //XYZ
        viewSrid:'EPSG:3857', 
    };
    
    INSTANCE_ol_Source; //생성자에 입력된 내용이 default 와 합쳐져 등록됨
    
    /**
     * @typedef {object} source_param Openlayers 소스객체 생성 팩토리 초기화 변수
     * @prop {number} [minZoom] 소스차원에서 zoom 설정. 10으로 정하면 view가 11로 확대되어도 레이어를 요청하지 않음(ol.source.XYZ 만 해당)
     * @prop {string} [viewSrid] 뷰포트의 기준 좌표계
     */
	
	
    /**
     * Creates an instance of SourceFactory.
     * @param {source_param} par 소스팩토리 생성을 위한 object
     * @memberof SourceFactory
     */
    constructor(par){
        super();
        Object.assign(this.#default_sourceSpec, par);

        //EPSG:5181,5186 초기등록
        proj4.defs("EPSG:5186","+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs");
        proj4.defs("EPSG:5181","+proj=tmerc +lat_0=38 +lon_0=127 +k=1 +x_0=200000 +y_0=500000 +ellps=GRS80 +units=m +no_defs");
        register(proj4);
    }

    getSource() {
        if(!this.INSTANCE_ol_Source) {
            try{
                this.INSTANCE_ol_Source = this.#buildSource();
            }catch(e){
                console.error(e);
                return undefined;
            }
        }
        if(this.INSTANCE_ol_Source instanceof Source){
            return this.INSTANCE_ol_Source;
        }else{
            console.groupCollapsed(`해당 source 객체는 openlayers 인스턴스 아님`);
            console.log(inputLayerSpec);
            console.groupEnd();
            throw new Error(`해당 source 객체는 openlayers 인스턴스 아님`);
        }
    }

    /**
     * 동적으로 feature 를 추가하기위해 vector Source 를 발행함 (주소검색용)
     * @returns {VectorSource}
     */
    getSimpleVectorSource(){
        return new VectorSource(this.#default_sourceSpec);
    }
    
    
    /**
     * 초기화
     */
    resetFactory(){
        super.resetFactory();        
        this.INSTANCE_ol_Source = undefined;
    }

    /**
     * 사용할 수 있는 Openlayers source 객체의 url 을 구성함
     *
     * @param {Object} inputLayerSpec
     * @return {} Openlayers source 파라미터로 사용할 수 있는 URL 폼
     * @memberof MOSourceConfig
     */
    #buildSource() {
        if (this.isValid_category_source()) {
            if(this.getSpec()[KEY.SOURCE_CATEGORY] == KEY.VIRTUAL_SOURCE_LAYER_KEY){
                return this.getSimpleVectorSource();
            }
            try {
                return this.srcBuilder(
                    this.getSpec()[KEY.SOURCE_CATEGORY],
                    this.getSpec()[KEY.SOURCE_CLASS]
                );
            } catch (e) {
				console.error(e);
                console.groupCollapsed(`openlayers source 객체 생성실패`);
                console.table(this.getSpec());
                console.groupEnd();
                throw new Error(`openlayers source 객체 생성실패`);
            } 
        }
    }

    /**
     * 레이어 소스를 만들기 위한 '카테고리' 와 '소스타입' 가 적합한지 확인
     * '카테고리'는 vworld, geoserver 등 gis 데이터를 가져오기위한 약식 출처구분
     * '소스타입' 은 레이어 구성을 위한 소스의 종류를 구분 (vector, xyz, wmts)
     * 
     * 본 클래스 내에서 다룰 수 있는지 여부를 우선으로 판가름함
     * @returns {boolean}
     */
    isValid_category_source() {
        let bool = false;
        let category = this.getSpec()[KEY.SOURCE_CATEGORY]; //vworld, geoserver, emap etc.
        let sourceClass = this.getSpec()[KEY.SOURCE_CLASS]; //vector, xyz, wmts etc.
        //가상 레이어일 때
        if(category == KEY.VIRTUAL_SOURCE_LAYER_KEY){
            return true;
        }

        if(!(category &amp;&amp; sourceClass)){
            console.groupCollapsed(`"category" 및 "source_type" 지정안됨`);
            console.table(this.getSpec());
            console.groupEnd();
            return false;
        }

        //현재는 이 도메인과 소스타입으로만 구성중임
        const AVAILABLE_CATEGORY_SOURCE = [
            { category: `vworld`, sourceClass: `wmts` },
            { category: `vworld`, sourceClass: `xyz` },
            { category: `geoserver`, sourceClass: `geojson` },
            { category: `geoserver`, sourceClass: `vector` },
        ];

        bool = AVAILABLE_CATEGORY_SOURCE.some(
            (e) => e.category == category &amp;&amp; e.sourceClass == sourceClass
        );
        if (!bool) {
            console.groupCollapsed(`유효하지 않은 category, sourceClass 지정`);
            console.table(this.getSpec());
            console.groupEnd();
        }
        return bool;
    }

    /**
     *
     * @param {String} category 카테고리
     * @param {String} sourceClass 소스타입
     * @returns {Source}
     */
    srcBuilder(category, sourceClass) {
        if (category == `geoserver` &amp;&amp; sourceClass == `vector`) {
            return this.srcBuilder_vector();

        } else if (category == `vworld` &amp;&amp; sourceClass == `xyz`) {
            
            return this.srcBuilder_xyz();

        } else if (category == `vworld` &amp;&amp; sourceClass == `wmts`) {
            return this.srcBuilder_wmts();
        } else {
            console.log(`정의되지 않은 category, sourceClass`);
            console.log(category, sourceClass);
            throw new Error(`정의되지 않은 category, sourceClass`);
        }
    }

    #getValidSrid() {
        let SRID = this.getSpec()[KEY.SRID];
        if (SRID) {
            //SRID == 'EPSG:5181' &lt;--- 콜론 포함 이 형태가 되어야 함
            //SRID == 'EPSG4326'
            //SRID == '4326'
            SRID = SRID.trim();
            if (SRID.startsWith(`EPSG:`)) {
            } else if (SRID.includes(`EPSG`)) {
                SRID = `EPSG:` + SRID.split(`EPSG`)[1];
            } else if (/^\d+$/.test(SRID)) {
                //숫자로만 이뤄져있나
                SRID = `EPSG:` + SRID;
            } else {
                throw new Error(`SRID 가 유효하지 않음 : ${SRID}`);
//                SRID = undefined;
            }
            return SRID;
        }
    }

    /**
     *
     * @returns {URL}
     */
    #urlBuilder_geoserver() {
        let origin = this.getSpec()[KEY.ORIGIN] ?? location.origin;
        let pathName = this.getSpec()[KEY.SOURCE_PATHNAME]; // "/geoserver/waternet/wfs/";
        let returnURL;
        if (pathName) {
            returnURL = new URL(pathName, origin); //origin 은 sourceURL 이 absolute 라면 무시됨
            const typeName = this.getSpec()[KEY.TYPE_NAME]; // "waternet:WTL_BLSM_AS_YS" etc.
            let paramString = new URLSearchParams();
            //WFS getFeature v2.0.0 공통 request
            //https://docs.geoserver.org/2.23.x/en/user/services/wfs/reference.html#getfeature
            paramString.set("service", "wfs");
            paramString.set("request", "getFeature");
            paramString.set("version", "2.0.0");
            paramString.set("typeName", typeName); // :, %, &amp; 등 특수기호들 uri 유효 형식으로 변환
            paramString.set(`outputFormat`,`application/json`);
            const cqlFilter = this.getSpec()[KEY.CQL_FILTER];
            if (cqlFilter) {
                paramString.set(`cql_filter`, cqlFilter);
            }

            // paramString.set('srsName','EPSG:3857');

            returnURL.search=paramString.toString();

            return returnURL;
        } else {
            console.groupCollapsed(`source URL 이 정의되지 않음`);
            console.log(this.getSpec());
            throw new Error(`source URL 이 정의되지 않음`);
        }
    }
    #urlBuilder_vworld_xyz() {
        let origin = this.getSpec()[KEY.ORIGIN] ??location.origin;
        let pathName = this.getSpec()[KEY.SOURCE_PATHNAME]; // "http://xdworld.vworld.kr:8080/2d/Satellite/service/{z}/{x}/{y}.jpeg";
        if (pathName) {
            return new URL(pathName, origin); //origin 은 sourceURL 이 absolute 라면 무시됨
        } else {
            console.groupCollapsed(`source URL 이 정의되지 않음`);
            console.log(this.getSpec());
            throw new Error(`source URL 이 정의되지 않음`);
        }
    }

    /**
     * vworld WebMapTileService 의 getCompatibilities 방식을 사용한 MapTile 소스 빌드
	 * 2023-12월 기준 vworld getCompatibilities 내용을 미리 저장해 놓고 APIKEY 만 교체해서 사용하고 있음    
     */
    srcBuilder_wmts(){
         if(this.#isValid_apiKey()){
            const typeName = this.getSpec()[KEY.TYPE_NAME];
            const wmtsConfigTemplate = vworld_compatibilities.replaceAll('{{{ $APIKEY }}}',this.getSpec()[KEY.APIKEY]);
            let result = new WMTSCapabilities().read(wmtsConfigTemplate);
            let sourceOption;
            if(typeName){
                sourceOption = optionsFromCapabilities(result, {layer:typeName});
                return new WMTS(sourceOption);
            }else{
                console.error(`invalid typeName : ${typeName}`);
                throw new Error(`invalid typeName : ${typeName}`);
            }
        }
    }


    srcBuilder_vector(userSrid){
        let geojson_option={};
            
        let srid = userSrid || this.#getValidSrid();
        let geoUrl ;
        try{
            geoUrl = this.#urlBuilder_geoserver();
        }catch(e){
            console.error(e);
        }
        if(srid) {
            geojson_option[`dataProjection`]=srid;
            geojson_option[`featureProjection`]=this.#default_sourceSpec.viewSrid;
        }
        let vectorOption;
        try{
            vectorOption={
                format: new GeoJSON(geojson_option),
                url: geoUrl.toString(),
            };
        }catch(e){
            console.log(e);
        }
        vectorOption = Object.assign({},this.#default_sourceSpec,vectorOption);
        let vectorSource;
        try{
            vectorSource = new VectorSource(vectorOption);
        }catch(e){
            console.error(e)
        }finally{
            return vectorSource;
        }
    }

	/** 구 xyz 소스 */
    srcBuilder_xyz(){
        let sourceOption={
            url: this.#urlBuilder_vworld_xyz(),
            maxZoom : 19,
            crossOrigin :'anonymous',
        }
        let srid = this.#getValidSrid();
        if(srid) sourceOption[`projection`] = srid;
        sourceOption = Object.assign({}, this.#default_sourceSpec, sourceOption);

        return new XYZ(sourceOption);
//        return new ol.source.XYZ(sourceOption);
    }
    
    #isValid_apiKey(){
        let bool = false;
        let apiKey = this.getSpec()[KEY.APIKEY];
        if(apiKey){
            //TODO 추가적인 API 키 유효성 검증 로직이 있으면 추가
            bool = true;
        }else{
            console.groupCollapsed(`apiKey 정보가 입력되지 않음`);
            console.log(this.getSpec());
            throw new Error (`apiKey 정보가 입력되지 않음`);
        }
        return bool;
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-ol_Overlay.html">ol/Overlay</a></li></ul><h3>Classes</h3><ul><li><a href="LayerFactory.html">LayerFactory</a></li><li><a href="LayerFactory.exports.LayerFactory.html">exports.LayerFactory</a></li><li><a href="LayerTree.html">LayerTree</a></li><li><a href="LayerTree_LayerTree.html">LayerTree</a></li><li><a href="LayerTree_new.html">LayerTree_new</a></li><li><a href="LayerTree_new_LayerTree.html">LayerTree</a></li><li><a href="MOFactory.html">MOFactory</a></li><li><a href="MOGISMap.html">MOGISMap</a></li><li><a href="MOGISMap_MOGISMap.html">MOGISMap</a></li><li><a href="MOLegend.html">MOLegend</a></li><li><a href="MOLegend_MOLegend.html">MOLegend</a></li><li><a href="MOMeasure.html">MOMeasure</a></li><li><a href="MOPagin.html">MOPagin</a></li><li><a href="MOPagin_MOPagin.html">MOPagin</a></li><li><a href="MOPublisher.html">MOPublisher</a></li><li><a href="MOSimpleMap.html">MOSimpleMap</a></li><li><a href="MOSourceConfig.html">MOSourceConfig</a></li><li><a href="MOSubscriber.html">MOSubscriber</a></li><li><a href="MapViewKit.html">MapViewKit</a></li><li><a href="SourceFactory.exports.SourceFactory.html">exports.SourceFactory</a></li><li><a href="SourceFactoryIntra.html">SourceFactoryIntra</a></li><li><a href="StyleFactory.html">StyleFactory</a></li><li><a href="TileLoadProgress.html">TileLoadProgress</a></li><li><a href="module-ol_Overlay.MOOverlay.html">MOOverlay</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ADDRESS_SOURCE_LAYER_KEY">ADDRESS_SOURCE_LAYER_KEY</a></li><li><a href="global.html#ARC_LAYER_ID">ARC_LAYER_ID</a></li><li><a href="global.html#CHILD_MARK">CHILD_MARK</a></li><li><a href="global.html#HIGHLIGHT_SOURCE_LAYER_KEY">HIGHLIGHT_SOURCE_LAYER_KEY</a></li><li><a href="global.html#LAYER_ID">LAYER_ID</a></li><li><a href="global.html#LAYER_NAME">LAYER_NAME</a></li><li><a href="global.html#LAYER_PURPOSE_CATEGORY">LAYER_PURPOSE_CATEGORY</a></li><li><a href="global.html#MAP">MAP</a></li><li><a href="global.html#OL_GEOMETRY_OBJ">OL_GEOMETRY_OBJ</a></li><li><a href="global.html#PARENT_ID">PARENT_ID</a></li><li><a href="global.html#POLYGON_SELECT_MARGINAL_RESOLUTION">POLYGON_SELECT_MARGINAL_RESOLUTION</a></li><li><a href="global.html#SOURCE_CATEGORY">SOURCE_CATEGORY</a></li><li><a href="global.html#SOURCE_CLASS">SOURCE_CLASS</a></li><li><a href="global.html#TYPE_NAME">TYPE_NAME</a></li><li><a href="global.html#VIEW">VIEW</a></li><li><a href="global.html#VIRTUAL_SOURCE_LAYER_KEY">VIRTUAL_SOURCE_LAYER_KEY</a></li><li><a href="global.html#base">base</a></li><li><a href="global.html#closeSearchModal">closeSearchModal</a></li><li><a href="global.html#comp">comp</a></li><li><a href="global.html#createStyleFunction">createStyleFunction</a></li><li><a href="global.html#createStyleFunctionForScale">createStyleFunctionForScale</a></li><li><a href="global.html#default">default</a></li><li><a href="global.html#default_spec">default_spec</a></li><li><a href="global.html#depthTabsAddress">depthTabsAddress</a></li><li><a href="global.html#getLayerCode">getLayerCode</a></li><li><a href="global.html#getLayerType">getLayerType</a></li><li><a href="global.html#getStyleFunc_POINT">getStyleFunc_POINT</a></li><li><a href="global.html#getTextStyle">getTextStyle</a></li><li><a href="global.html#getUpdatedLayerCode">getUpdatedLayerCode</a></li><li><a href="global.html#gisSearch">gisSearch</a></li><li><a href="global.html#iconPath">iconPath</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#jsonNestor">jsonNestor</a></li><li><a href="global.html#layer">layer</a></li><li><a href="global.html#leak">leak</a></li><li><a href="global.html#manage">manage</a></li><li><a href="global.html#mapModifier">mapModifier</a></li><li><a href="global.html#mergeMaps">mergeMaps</a></li><li><a href="global.html#mgcInform">mgcInform</a></li><li><a href="global.html#pipenet">pipenet</a></li><li><a href="global.html#portable">portable</a></li><li><a href="global.html#projection">projection</a></li><li><a href="global.html#public">public</a></li><li><a href="global.html#realtime">realtime</a></li><li><a href="global.html#risk">risk</a></li><li><a href="global.html#searchFeature">searchFeature</a></li><li><a href="global.html#source">source</a></li><li><a href="global.html#target">target</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed Feb 21 2024 20:55:10 GMT+0900 (대한민국 표준시)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
