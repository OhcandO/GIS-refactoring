<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: classes/MO.SourceFactory_intra.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: classes/MO.SourceFactory_intra.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as KEY from '../common/MO.keyMap.js';
import { SourceFactory } from "./MO.SourceFactory.js";
import TileArcGISRest from "../../lib/openlayers_v7.5.1/source/TileArcGISRest.js";
import VectorSource from '../../lib/openlayers_v7.5.1/source/Vector.js';
import Feature from '../../lib/openlayers_v7.5.1/Feature.js';
import Source from '../../lib/openlayers_v7.5.1/source/Source.js';
import WKT from '../../lib/openlayers_v7.5.1/format/WKT.js';

/**
 * 내부망 non-geoserver 환경에서 ol.source 객체를 생성하기 위한 메서드 추가
 * 범용적인 SourceFactory 보다는 프로젝트 연관성이 짙은 메서드를 따로 빼기 위함
 */
export class SourceFactoryIntra extends SourceFactory {
	
	
	 isValid_category_source() {
        let bool = false;
        let category = this.getSpec()[KEY.SOURCE_CATEGORY]; //vworld, geoserver, emap,virtual etc.
        let sourceClass = this.getSpec()[KEY.SOURCE_CLASS]; //vector, xyz, wmts etc.
        //가상 레이어일 때
        if(category == KEY.VIRTUAL_SOURCE_LAYER_KEY){
            return true;
        }

        if(!(category &amp;&amp; sourceClass)){
            console.groupCollapsed(`"category" 및 "source_type" 지정안됨`);
            console.table(this.getSpec());
            console.groupEnd();
            return false;
        }

        //현재는 이 도메인과 소스타입으로만 구성중임
        const AVAILABLE_CATEGORY_SOURCE = [
            { category: `vworld`, sourceClass: `wmts` },
            { category: `vworld`, sourceClass: `xyz` },
            { category: `geoserver`, sourceClass: `geojson` },
            { category: `geoserver`, sourceClass: `vector` },
            { category: `intra`, sourceClass: `vector` },
            { category: `intra`, sourceClass: `arcgis` },
        ];

        bool = AVAILABLE_CATEGORY_SOURCE.some(
            (e) => e.category == category &amp;&amp; e.sourceClass == sourceClass
        );
        if (!bool) {
            console.groupCollapsed(`유효하지 않은 category, sourceClass 지정`);
            console.table(this.getSpec());
            console.groupEnd();
        }
        return bool;
    }
	
	/**
     *
     * @param {String} category 카테고리
     * @param {String} sourceClass 소스타입
     * @returns {Source}
     */
    srcBuilder(category, sourceClass) {
        if (category == `geoserver` &amp;&amp; sourceClass == `vector`) {
            return this.srcBuilder_vector();
        } else if (category == `vworld` &amp;&amp; sourceClass == `xyz`) {
            return this.srcBuilder_xyz();
        } else if (category == `vworld` &amp;&amp; sourceClass == `wmts`) {
            return this.srcBuilder_wmts();
        } else if (category == `intra` &amp;&amp; sourceClass == `arcgis`) { //내부망 arcGis 타일맵 서버 대응
            return this.srcBuilder_arcGis();
        } else if (category == `intra` &amp;&amp; sourceClass == `vector`) { //geoserver 거치지 않고 wkt feature 파싱
        
            return this.srcBuilder_wktFeature();
        } else {
            console.log(`정의되지 않은 category, sourceClass`);
            console.log(category, sourceClass);
            throw new Error(`정의되지 않은 category, sourceClass`);
        }
    }
    
    /** 내부망 arcGis 타일맵 요청 소스 빌드 */
    srcBuilder_arcGis(){
		return new TileArcGISRest({
			url:`${this.getSpec()[KEY.ORIGIN]}${this.getSpec()[KEY.SOURCE_PATHNAME]}`,
		})
	}
	
	/** WKT 방식 feature 파싱. non-geoserver getFeatures method 
	 * @param {KEY.layerCodeObj} layerCodeObject    
	*/
	srcBuilder_wktFeature(layerCodeObject){
        const src = layerCodeObject ?? this.getSpec();
        const origin = src[KEY.ORIGIN] ?? location.origin;
        const pathname = src[KEY.SOURCE_PATHNAME];
        
        //! WAS서버에 이 url을 처리할 수 있는 로직이 있는지 확인할 것
        let returnURL = new URL(`${ctxPath+pathname}`,origin); //contextPath 추가
        const typeName = src[KEY.TYPE_NAME];
        let cqlFilter = src[KEY.CQL_FILTER] ??'';
        
        //arcLayerId 의 cqlFilter 화
        const arcLayerId = src[KEY.ARC_LAYER_ID];
        
//        if(arcLayerId){
//			cqlFilter += this.#querializeForWASapi(arcLayerId);
//		}
        
        const srid = src[KEY.SRID];
        
        /** @type {VectorSource} */
        let returnSource;
//        let paramString = new URLSearchParams({
//			typeName:typeName,
//			cqlFilter:cqlFilter ??'',
//			arcLayerId:arcLayerId ?? ''
//		});
        let paramString = new URLSearchParams();
        paramString.set(KEY.TYPE_NAME,typeName);
        if(cqlFilter) paramString.set(KEY.CQL_FILTER,cqlFilter);
        if(arcLayerId) paramString.set(KEY.ARC_LAYER_ID,arcLayerId);
        returnURL.search = paramString;
        
       //console.log(returnURL);
		
		try{
	        returnSource = new VectorSource({
	            format: new WKT(),
	            // 참고 : https://openlayers.org/en/v7.5.2/apidoc/module-ol_source_Vector-VectorSource.html
	            /* 		wkt::readFeatures 는 geom 컬럼만으로 Feature 객체 반환
	            		wkt::readGeometry 는 geom 컬럼으로 Geometry 객체 반환
	            */
				loader:function(extent, resolution, projection, success, failure){
					const proj = projection.getCode();
	                fetch(returnURL,{method:'get', headers:{"x-requested-with":'XMLHttpRequest'}})
	                .then(res=>res.ok ? res.json() : Promise.reject(`getWktFeatures 응답에러`))
	                .catch(console.error)
	                .then(res=>res['features'])
	                .then(wktFeatures=>{
						let featureArr = [];
						if(wktFeatures instanceof Array){
							const KEY_GEOMETRY_COLUMN = 'GEOMETRY'; // WAS에서 지정한 wkt 요소의 컬럼명
							const formatt = returnSource.getFormat();
							wktFeatures.forEach(wktFeature=>{
								let geomColumn = wktFeature[KEY_GEOMETRY_COLUMN]; // 'POINT(....)' 등 wkt 형식 요소
								wktFeature.geometry= formatt.readGeometry(geomColumn,{dataProjection:srid, featureProjection:proj});
								featureArr.push(new Feature(wktFeature));
							}); 
						}else{
							console.log(`vectorSource 에 feature 없음`);
							failure(featureArr)
						}
	                    returnSource.addFeatures(featureArr);
	                    success(featureArr);
	                });
				}
	        });
//	        console.log(returnSource)
		}catch(e){
			console.log(e);
		}
        if(returnSource) return returnSource;
        else return new Error(`wkt 부적합`);
	}
	
	/**
	 * layerCodeObj 속성 중 하나인 arcLayerId 를 cqlFilter 요소로 변경시키는 로직
	 * @param {string} arcLayerId
	 * @returns {string} 
	 * @deprecated
	 */
	#querializeForWASapi(arcLayerId){
		let returnString = '';
		if(arcLayerId.includes(',')){
			const tempStr = arcLayerId.split(',').map(el=>`'${el.trim()}'`).join(',');
			returnString += ` LAYER_ID IN (${tempStr})`;
		}else{
			returnString += ` LAYER_ID='${arcLayerId}'`;
		}
		return returnString;
	}
	
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-ol_Overlay.html">ol/Overlay</a></li></ul><h3>Classes</h3><ul><li><a href="LayerFactory.html">LayerFactory</a></li><li><a href="LayerFactory.exports.LayerFactory.html">exports.LayerFactory</a></li><li><a href="LayerTree.html">LayerTree</a></li><li><a href="LayerTree_LayerTree.html">LayerTree</a></li><li><a href="LayerTree_new.html">LayerTree_new</a></li><li><a href="LayerTree_new_LayerTree.html">LayerTree</a></li><li><a href="MOFactory.html">MOFactory</a></li><li><a href="MOGISMap.html">MOGISMap</a></li><li><a href="MOGISMap_MOGISMap.html">MOGISMap</a></li><li><a href="MOLegend.html">MOLegend</a></li><li><a href="MOLegend_MOLegend.html">MOLegend</a></li><li><a href="MOMeasure.html">MOMeasure</a></li><li><a href="MOPagin.html">MOPagin</a></li><li><a href="MOPagin_MOPagin.html">MOPagin</a></li><li><a href="MOPublisher.html">MOPublisher</a></li><li><a href="MOSimpleMap.html">MOSimpleMap</a></li><li><a href="MOSourceConfig.html">MOSourceConfig</a></li><li><a href="MOSubscriber.html">MOSubscriber</a></li><li><a href="MapViewKit.html">MapViewKit</a></li><li><a href="SourceFactory.exports.SourceFactory.html">exports.SourceFactory</a></li><li><a href="SourceFactoryIntra.html">SourceFactoryIntra</a></li><li><a href="StyleFactory.html">StyleFactory</a></li><li><a href="TileLoadProgress.html">TileLoadProgress</a></li><li><a href="module-ol_Overlay.MOOverlay.html">MOOverlay</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ADDRESS_SOURCE_LAYER_KEY">ADDRESS_SOURCE_LAYER_KEY</a></li><li><a href="global.html#ARC_LAYER_ID">ARC_LAYER_ID</a></li><li><a href="global.html#CHILD_MARK">CHILD_MARK</a></li><li><a href="global.html#HIGHLIGHT_SOURCE_LAYER_KEY">HIGHLIGHT_SOURCE_LAYER_KEY</a></li><li><a href="global.html#LAYER_ID">LAYER_ID</a></li><li><a href="global.html#LAYER_NAME">LAYER_NAME</a></li><li><a href="global.html#LAYER_PURPOSE_CATEGORY">LAYER_PURPOSE_CATEGORY</a></li><li><a href="global.html#MAP">MAP</a></li><li><a href="global.html#OL_GEOMETRY_OBJ">OL_GEOMETRY_OBJ</a></li><li><a href="global.html#PARENT_ID">PARENT_ID</a></li><li><a href="global.html#POLYGON_SELECT_MARGINAL_RESOLUTION">POLYGON_SELECT_MARGINAL_RESOLUTION</a></li><li><a href="global.html#SOURCE_CATEGORY">SOURCE_CATEGORY</a></li><li><a href="global.html#SOURCE_CLASS">SOURCE_CLASS</a></li><li><a href="global.html#TYPE_NAME">TYPE_NAME</a></li><li><a href="global.html#VIEW">VIEW</a></li><li><a href="global.html#VIRTUAL_SOURCE_LAYER_KEY">VIRTUAL_SOURCE_LAYER_KEY</a></li><li><a href="global.html#base">base</a></li><li><a href="global.html#closeSearchModal">closeSearchModal</a></li><li><a href="global.html#comp">comp</a></li><li><a href="global.html#createStyleFunction">createStyleFunction</a></li><li><a href="global.html#createStyleFunctionForScale">createStyleFunctionForScale</a></li><li><a href="global.html#default">default</a></li><li><a href="global.html#default_spec">default_spec</a></li><li><a href="global.html#depthTabsAddress">depthTabsAddress</a></li><li><a href="global.html#getLayerCode">getLayerCode</a></li><li><a href="global.html#getLayerType">getLayerType</a></li><li><a href="global.html#getStyleFunc_POINT">getStyleFunc_POINT</a></li><li><a href="global.html#getTextStyle">getTextStyle</a></li><li><a href="global.html#getUpdatedLayerCode">getUpdatedLayerCode</a></li><li><a href="global.html#gisSearch">gisSearch</a></li><li><a href="global.html#iconPath">iconPath</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#jsonNestor">jsonNestor</a></li><li><a href="global.html#layer">layer</a></li><li><a href="global.html#leak">leak</a></li><li><a href="global.html#manage">manage</a></li><li><a href="global.html#mapModifier">mapModifier</a></li><li><a href="global.html#mergeMaps">mergeMaps</a></li><li><a href="global.html#mgcInform">mgcInform</a></li><li><a href="global.html#pipenet">pipenet</a></li><li><a href="global.html#portable">portable</a></li><li><a href="global.html#projection">projection</a></li><li><a href="global.html#public">public</a></li><li><a href="global.html#realtime">realtime</a></li><li><a href="global.html#risk">risk</a></li><li><a href="global.html#searchFeature">searchFeature</a></li><li><a href="global.html#source">source</a></li><li><a href="global.html#target">target</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed Feb 21 2024 21:05:04 GMT+0900 (대한민국 표준시)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
